<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Twisted Introduction</title>
<!-- metadata -->
<meta name="generator" content="S5" />
<meta name="version" content="S5 1.1" />
<meta name="presdate" content="20100323" />
<meta name="author" content="Dustin J. Mitchell" />
<meta name="company" content="Zmanda, Inc." />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/ps1/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/ps1/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/ps1/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/ps1/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- S5 JS -->
<script src="ui/ps1/slides.js" type="text/javascript"></script>
<!-- SHJS JS & CSS -->
<script type="text/javascript" src="shjs/sh_main.min.js"></script>
<script type="text/javascript" src="shjs/sh_python.min.js"></script>
<link type="text/css" rel="stylesheet" href="shjs/sh_emacs.min.css">

<!-- set up both SHJS and S5 -->
<script lang="JavaScript">
    window.onload = function() {
        sh_highlightDocument();
        startup();
    }
</script>

<!-- don't force a solid white background on source code -->
<style>
pre.sh_python { background: inherit }
</style>
</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1>Twisted Introduction</h1>
<h2>Dustin J. Mitchell</h2>
</div>

</div>


<div class="presentation">

<div class="slide">
<h1>Twisted Introduction</h1>
<h3>Dustin J. Mitchell</h3>
<h4>Zmanda, Inc.</h4>
</div>


<div class="slide">
<h1>Asynchronous Programming</h1>
<p>An alternative to threading for multiprocessing: faster, fewer resources, fewer synchronization problems<p>
<ul>
    <li>Built around an <i> event loop</i>, calling functions to react to events.</li>
    <li>All actions are non-blocking, so the app is "usually" waiting for events.</li>
    <li>Example: GUI application</li>

    <li>Implementations:
        <a href="http://poe.perl.org/">POE</a> (perl),
        <a href="http://docs.python.org/library/asyncore.html">asyncore</a> (Python),
        <a href="http://twistedmatrix.org/">Twisted</a> (Python),
        Glib's <a href="http://library.gnome.org/devel/glib/unstable/glib-The-Main-Event-Loop.html">GMainLoop</a> (C)</li>

</ul>
<div class="handout">

    <p>The system requirements for an asynchornous programming environment are
    the ability to do non-blocking IO, which means that functions like
    <tt>read</tt> and <tt>write</tt> will not block until data is available;
    and the ability to monitor multiple IO channels for activity
    simultaneously, usually via the <tt>select</tt> or <tt>poll</tt>
    syscall.</p>

    <p>Basic asynchronous style implements the idea of starting an operation:
    when a user clicks this button, call this function.  But it breaks down
    when that function needs to do something more complex than drawing
    something onscreen - performing a database query, for example.</p>

    <p>We need something that can model an ongoing process without blocking.
    Sort of a deferred function return.</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: the model</h1>
<p><b>Deferred</b>: a result that's not ready yet</p>
<img style="float: right" src="example1.png" />
<ul>
    <li>Returned as a function result to indicate "I'm not done yet."</li>
    <li>A deferred is "fired" with a result value when the operation it represents is complete.</li>
    <li>Use <tt>addCallback</tt> to get called when the deferred fires:
<pre class="sh_python">
# see example1.py
def print_user_info(user):
    d = mydb.get_user(user)
    def got_info(res):
        print "name:", res.name
    d.addCallback(got_info)
</pre>
</ul>
<div class="handout">

    <p>This is a very basic model of deferreds, but it handles the notion of ongoing
    processes nicely.<p>

    <p>This particular style, using nested functions, is my favorite, but lots
    of people use separate (un-nested) functions instead.</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: chaining</h1>
<p>multiple callbacks are called in sequence</p>
<img style="float: right" src="example2.png" />
<pre class="sh_python">
# see example2.py
def get_user_name(user):
    d = mydb.get_user(user)
    def extract_name(res):
        if res:
            return res.name
        return "(unknown)"
    d.addCallback(extract_name)
    return d

def print_user_name(user):
    d = get_user_name(user)
    def print_name(name):
        print "Name:", name
    d.addCallback(print_name)
</pre>
<div class="handout">

    <p>Here two callbacks are added to the same deferred.  This is a common
    pattern: get a deferred, add a callback to do your thing, and return the
    same deferred.</p>

    <p>Note that the deferred is initially fired with a User object.  The
    <tt>extract_name</tt> callback returns a string, which is passed to the
    next callback in the chain, <tt>print_user_name</tt>.</p>

    <p>This is where API docs are useful: <tt>mydb.get_user</tt> returns a
    Deferred that fires with a user object.  <tt>get_user_name</tt> returns a
    Deferred that fires with the name of the user, or "(unknown)".</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: chaining example</h1>
<pre class="sh_python">
# see example2.py<img style="float: right" src="example2.png" />
def get_user_name(user):
    d = mydb.get_user(user)
    def extract_name(res):
        if res:
            return res.name
        return "(unknown)"
    d.addCallback(extract_name)
    return d

def print_user_name(user):
    d = get_user_name(user)
    def print_name(name):
        print "Name:", name
    d.addCallback(print_name)
</pre>
<div class="handout">

    <p>Here two callbacks are added to the same deferred.  This is a common
    pattern: get a deferred, add a callback to do your thing, and return the
    same deferred.</p>

    <p>Note that the deferred is initially fired with a User object.  The
    <tt>extract_name</tt> callback returns a string, which is passed to the
    next callback in the chain, <tt>print_user_name</tt>.</p>

    <p>This is where API docs are useful: <tt>mydb.get_user</tt> returns a
    Deferred that fires with a user object.  <tt>get_user_name</tt> returns a
    Deferred that fires with the name of the user, or "(unknown)".</p>

    <p>What about error handling?  What if <tt>mydb.get_user</tt> raises an
    exception?</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: errbacks</h1>
<img style="float: right" src="example3.png" />
<p>A deferred operation can fail, in which case the errback is called</p>
<pre class="sh_python">
# see example3.py
def print_page_title(url):
    d = get_page_title(url)
    def got_info(title):  # callback
        print "title:", title
    def fail_info(f):     # errback
        print "failed!", f.type, f.value
        # (consume the error)
    d.addCallbacks(got_info, fail_info)
</pre>
<div class="handout">

    <p>If <tt>get_page_title</tt> succeeds, then <tt>fail_info</tt> is never called.
    However, if the operation fails, then <tt>got_info</tt> is never called.  Instead,
    <tt>fail_info</tt> is called wth a <tt>Failure</tt> object.  Failures wrap Exception
    objects.</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: multiple</h1>
<img style="float: right" src="full-cbeb.png" />
<p><b>Multiple Callback and Errbacks</b></p>
<ul>
    <li>Callbacks and errbacks come in pairs</li>
    <li>If a callback raises an exception, then execution switches to errbacks</li>
    <ul>
        <li>Note that an exception in the original operation is not handled like this!</li>
    </ul>
    <li>If an errback does not re-raise the Failure, then execution switches back to callbacks</li>
    <ul>
        <li>Be careful that nonterminal errback handlers return <tt>f</tt>!</li>
    </ul>
</ul>
<div class="handout">

    <p>This is the "full grid" of callbacks and errbacks.  Execution can, in
    principal, switch back and forth from callbacks to errbacks several times
    for a single deferred.</p>
    <br clear="all" />

</div>
</div>


<div class="slide">
<h1>Deferreds: multiple example</h1>
<pre class="sh_python">
def get_contacts(username):
    d = im_service.get_contact_list(username)
    def cb(contacts):<img style="float: right" src="web-cbeb.png" />
        return [ ctct.username for ctct in contacts ]
    def eb(f):
        print "err getting contacts for %s: %s" \
            % (username, f.value)
        return f
    d.addCallbacks(cb, eb)
    return d

def ajax_get_contacts(request):
    d = get_contacts(request.query['username'][0]) # BUG
    def cb(ctctnames):
        return json.dumps({'contacts' : ctctnames})
    def eb(f):
        return json.dumps({'error' : str(f.value))
    d.addCallbacks(cb, eb)
    return d
</pre>
<div class="handout">

    <p>This is a somewhat overwrought example of a full set of callbacks and
    errbacks.  Note that, because it just logs the error, the errback for
    <tt>get_contacts</tt> always returns the failure, passing it along to
    <tt>ajax_get_contacts</tt>' errback.  This is what I mean by a
    "nonterminal" errback.</p>

    <p>However, the errback in <tt>ajax_get_contacts</tt> *is* terminal.
    Presumably this function's deferred is expected to fire with a JSON string
    to hand back to the browser, and we want to handle error reporting with
    JavaScript and not with the usual browser mechanisms.  So the failure is
    "eaten" here, and the web framework's callback, not its errback, will be
    called next.</p>

    <p>Note that an exception in <tt>im_service.get_contact_list</tt> will
    leave the deferred un-called-back.  This is bad!  Don't allow this to
    happen!</p>

    <p>However, an exception in the callback for <tt>get_contacts</tt> (maybe a
    contact object without a <tt>username</tt> attribute?) will cause the
    errback <b>in <tt>ajax_get_contacts</tt></b> to be called and it will
    report the error correctly.  Note that the errback for
    <tt>get_contacts</tt> is not called in this case!</p>

    <p>There's still a bug here: if no username is specified, then
    <tt>ajax_get_contacts</tt> will raise an exception that probably won't be
    handled very well by the web framework (it will probably create a lot of
    HTML that will not parse as JSON).</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: skipping errbacks</h1>
<pre class="sh_python">
def get_contacts(username):
    d = im_service.get_contact_list(username)
    def cb(contacts):<img style="float: right" src="web-simpler.png" />
        return [ ctct.username for ctct in contacts ]
    d.addCallback(cb)
    return d

def ajax_get_contacts(request):
    d = get_contacts(request.query['username'][0]) # BUG
    def cb(ctctnames):
        return json.dumps({'contacts' : ctctnames})
    def eb(f):
        return json.dumps({'error' : str(f.value))
    d.addCallbacks(cb, eb)
    return d
</pre>
<div class="handout">

    <p>This example is slightly simpler.  Any error in
    <tt>im_service.get_contact_list</tt> will go directly to
    <tt>ajax_get_contacts</tt>' errback method, which will report it to the
    JavaScript in the browser correctly.</tt>

    <p>There's still a bug here: if no username is specified, then
    <tt>ajax_get_contacts</tt> will raise an exception.  The web frameworkd
    is probably prepared to handle a <i>failure</i>, but not an exception.</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: succeed</h1>
Handle non-existent username with a JSON error:
<pre class="sh_python">
from twisted.internet import defer
def ajax_get_contacts(request):
    try:
        username = request.query['username'][0]
    except KeyError:
        return defer.succeed(
            json.dumps({'error' : 'no username specified'}))

    d = get_contacts(username)
    def cb(ctctnames):
        return json.dumps({'contacts' : ctctnames})
    def eb(f):
        return json.dumps({'error' : str(f.value))
    d.addCallbacks(cb, eb)
    return d
</pre>
<div class="handout">

    <p>This is one way to solve the problem: shortcut the whole contact lookup,
    and return an <i>already-fired</i> Deferred object to the web framework.</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: fail</h1>
..or return a failure..
<pre class="sh_python">
from twisted.internet import defer
def ajax_get_contacts(request):
    try:
        username = request.query['username'][0]
    except KeyError:
        return defer.fail() # use current exception

    d = get_contacts(username)
    def cb(ctctnames):
        return json.dumps({'contacts' : ctctnames})
    def eb(f):
        return json.dumps({'error' : str(f.value))
    d.addCallbacks(cb, eb)
    return d
</pre>
<div class="handout">

    <p>Here, we return a failure automatically built from the <tt>KeyError</tt> to the web framework</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: nesting</h1>
..or handle it <i>in</i> a callback..
<pre class="sh_python">
from twisted.internet import defer<img style="float: right" src="nested.png" />
def get_contacts(username):
    d = im_service.get_contact_list(username)
    def cb(contacts):
        return [ ctct.username for ctct in contacts ]
    d.addCallback(cb)
    return d

def ajax_get_contacts(request):
    d = defer.succeed(None)
    def get_username(_): # ignore argument
        return request.query['username'][0]
    d.addCallback(get_username)
    d.addCallback(get_contacts) # this returns a deferred!
    def json_cb(ctctnames):
        return json.dumps({'contacts' : ctctnames})
    def json_eb(f):
        return json.dumps({'error' : str(f.value))
    d.addCallbacks(json_cb, json_eb)
    return d
</pre>
<div class="handout">

    <p>This moves the entire operation <i>into</i> the callback chain, by
    starting with an already-fired callback, and getting the username in the
    first callback.  Callbacks always take an argument, and <tt>_</tt> is a good
    way to indicate "I'm ignoring this argument".</p>
    
    <p><tt>get_username</tt> returns the username, which is then handed as a
    single argument to the next callback.<p>

    <p>That callback is <tt>get_username</tt> which coincidentally takes a
    single arugment.  However, it returns a deferred.  Why does
    <tt>json_cb</tt> not get called with a deferred?  Twisted automatically
    "nests" deferreds -- it basically adds the callbacks and errbacks from the
    inner deferred to the outer deferred.  What actually happens is much more
    complex, since more callbacks and errbacks could be added to that inner
    deferred later, but let's not think about that right now.</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: methods</h1>
<pre class="sh_python">
# add a callback
d.addCallback(cb, *args, **kwargs)
# add an errback
d.addErrback(cb, *args, **kwargs)
# add one of each (side by side)
d.addCallbacks(cb, eb)
# add the same callable as callback and errback
d.addBoth(callable)
# fire with success
d.callback(result)
# fire with a failure from the current exception
d.errback()
# fire with a given failure
d.errback(f)
# new, fired Deferred
d = defer.succeed(result)
# new, failed Deferred
d = defer.fail(f=current_exception)
</pre>
</div>


<div class="slide">
<h1>Deferreds: recap</h1>
<ul>
    <li>A Deferred represents a result that's not ready yet</li>
    <li>Has an attached sequence of callbacks and errbacks</li>
    <li>Can be nested
    <ul>
        <li>Note that infinite nesting (like tail recursion) is bad!</li>
    </ul></li>
    <li>Conceptually distinct from async IO
    <ul>
        <li>Haven't talked about sockets or pipes yet!</li>
    </ul></li>
    </li>
</ul>
<div class="handout">

    <p>Deferreds are conceptually fairly simple, although there are some gotchas.</p>

    <p>Note that we haven't looked at direct asynchronous IO -- sockets, pipes,
    etc.  In fact, Twisted generally uses function or method calls to handle
    those, e.g., <tt>lineReceived</tt> for the <a
        href="http://twistedmatrix.com/documents/8.2.0/api/twisted.protocols.basic.LineReceiver.html"><tt>LineReceiver</tt></a>
    class.</p>

</div>
</div>


<div class="slide">
<h1>Deferreds: sync and async</h1>
<table width="100%">
    <tr><th align="left">sync</th><th align="left">async</th></tr>
    <tr><td>function call</td><td>return deferred</td></tr>
    <tr><td>sequential execution</td><td><tt>d.addCallback() and return</tt></td></tr>
    <tr><td>function return</td><td><tt>d.callback()</tt></td></tr>
    <tr><td>raise exception</td><td><tt>d.errback()</tt></td></tr>
    <tr><td>new thread</td><td>call deferred func &amp; don't return</td></tr>
    <tr><td>join thread</td><td>add callback to thread's deferred</td></tr>
</table>
<div class="handout">

    <p>With some careful programming, deferreds can model both sequential
    execution and threaded execution.  These "threads" are lightweight and can
    be created and destroyed easily, and of course synchronization requirements
    are minimal.</p>

    <p><i>Not</i> following careful programming can lead to buggy, confusing
    spaghetti code.  In particular, think about starting a new "thread" vs.
    sequential execution.</p>

</div>
</div>


<div class="slide">
<h1>Utilities: DeferredList</h1>
<pre class="sh_python">
from twisted.internet.defer import <a href="http://twistedmatrix.com/documents/8.2.0/api/twisted.internet.defer.DeferredList.html">DeferredList</a>

def parallelLookup(usernames):
    dl = []
    for username in usernames:
        dl.append(get_user_info(username))
    dl = DeferredList(dl, consumeErrors=True)
    def process(results):
        rv = {}
        for username, result in zip(usernames, results):
            if results[0]:
                rv[username] = results[1]
            else:
                rv[username] = None
        return rv
    dl.addCallback(process)
    return dl
</pre>
<div class="handout">

    <p>This calls <tt>get_user_info</tt> for each username, and then bundles
    all of the resulting Deferreds into a single DeferredList -- in a fashion,
    it starts a bunch of threads and then joins them.  DeferredList's behavior
    can be customized easily; in this case, it fires when all of its
    constituent deferreds are complete (fired or failed).  It ignores errors
    internally (<tt>consumeErrors</tt>), and passes back a tuple <tt>(success,
    result_or_failed)</tt> for each deferred.</p>

</div>
</div>


<div class="slide">
<h1>Utilities: callLater</h1>
<pre class="sh_python">
from twisted.python import defer
from twisted.internet import reactor

def countDown(N):
    d = defer.Deferred()
    def count(n):
        print n
        if n &gt; 0:
            defer.callLater(1, count, n-1)
        else:
            d.callback(None)
    count(N)
    return d
</pre>
<div class="handout">

    <p>Note that <tt>callLater</tt> does not use a Deferred -- just a
    callable.  The <tt>countDown</tt> function is on example of how a function
    can return a deferred and schedule it to fire later.</p>

</div>
</div>


<div class="slide">
<h1>Utilities: LoopingCall</h1>
<pre class="sh_python">
from twisted.python import defer
from twisted.internet.task import <a href="http://twistedmatrix.com/documents/9.0.0/api/twisted.internet.task.LoopingCall.html">LoopingCall</a>

def wait_for_file(filename, poll_interval = 1):
    d = defer.Deferred()
    def poll(filename):
        if os.path.exists(filename):
            l.stop()
            d.callback(None)
    l = LoopingCall(poll)
    l.start(poll_interval)
    return d
</pre>
<div class="handout">

    <p>LoopingCall calls its method on a schedule, specified to the
    <tt>start</tt> method.  It is often used to poll for changes, e.g., in the
    filesystem.</p>

</div>
</div>


<div class="slide">
<h1>Utilities: do not use</h1>
<p>If you feel like you need these, then there's probably a design error somewhere.</p>
<ul>
    <li>maybeDeferred</li>
    <li>Deferred.pause/unpause</li>
    <li>Deferred.setTimeout</li>
</ul>
</div>


<div class="slide">
<h1>Other Twisted Stuff</h1>
<p>Not covered in this tutorial, but you should learn about:</p>
<ul>
    <li><a href="http://twistedmatrix.com/documents/8.2.0/api/twisted.application.service.Service.html">Services</a>, <a href="http://twistedmatrix.com/documents/8.2.0/api/twisted.application.service.html#Application">Applications</a>, and <a href="http://twistedmatrix.com/documents/current/core/howto/application.html">twistd</a> (the Twisted daemon)</li>
    <li>Protocols</li>
    <li>Perspective Broker (Twisted RPC)</li>
    <li>The Twisted web frameworks: <a href="http://twistedmatrix.com/documents/current/web/howto/">web</a>, web2, Woven,
        <a href="http://divmod.org/trac/wiki/DivmodNevow">Nevow</a> (caution: never worked?), Mantissa
        (some of these were never documented)</li>
    <li><a href="http://twistedmatrix.com/documents/9.0.0/api/twisted.enterprise.adbapi.html">Enterprise</a> - database abstraction</li>
</ul>
<div class="handout">
    
    <p>A word of warning about Twisted: outside of the Twisted core, there are
    <i>many</i> abandoned projects.  Usually the older projects, labeled
    "deprecated, use $newstuff", are the projects you want to use.  The
    $newstuff was generally never finished.  For example, Axiom replaces
    Enterprise, but Axiom is not ready yet.</p>

    <p>Stick to the core, and do not be attracted by shiny things which sound
    like they might be useful.  If in doubt, ask other Twisted programmers who
    did not work for DivMod.</p>

</div>

</div>


<div class="slide">
<h1>Buildbot</h1>
<p>Starting a new application in Twisted is <i>hard</i> and not recommended.  For practice, consider working on <a href="http://buildbot.net">Buildbot</a>'s unit tests</p>
<ul>
    <li>Twisted's <tt>unittest</tt> is almost the same as Python's, but <tt>setUp</tt>, <tt>tearDown</tt>, and test methods can return deferreds.</li>
    <li>Need more tests in <tt>buildbot/test</tt>!
    <ul>
        <li>Warning: I am a stickler about tests! <a href="http://buildbot.net/trac/wiki/TowardBetterBuildbotTests">TowardBetterBuildbotTests</a></li>
    </ul>
    </li>
    <li>Suggestion: tests for code under <tt><a href="http://djmitche.github.com/buildbot/docs/0.8.0beta1/reference/buildbot.slave-module.html">buildbot.slave</a></tt></li>
    <li>Feel free to work on your own projects if you prefer</li>
</ul>
</div>


<div class="slide">
<h1>Get Started</h1>
<pre>
$ git clone git://github.com/djmitche/buildbot.git
$ virtualenv sandbox
$ source sandbox/bin/activate
(sandbox)$ python setup.py develop
(sandbox)$ trial buildbot.test
</pre>
(you can also fork the project on github if your git-fu is strong enough)
</div>


</div>

</body>
</html>
